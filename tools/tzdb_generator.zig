const std = @import("std");

const RawRule = struct {
    from: ?i64 = null,
    offset: i32,
    dst: i32,
    abbr: []const u8,
};

const RawTimeZone = struct {
    name: []const u8,
    rules: []RawRule,
};

const RawRoot = struct {
    version: []const u8,
    timezones: []RawTimeZone,
};

fn writeFormatted(file: *std.fs.File, allocator: std.mem.Allocator, comptime fmt: []const u8, args: anytype) !void {
    const line = try std.fmt.allocPrint(allocator, fmt, args);
    defer allocator.free(line);
    try file.writeAll(line);
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var input_path: ?[]const u8 = null;
    var output_path: ?[]const u8 = null;

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    var i: usize = 1;
    while (i < args.len) : (i += 1) {
        const arg = args[i];
        if (std.mem.eql(u8, arg, "--input")) {
            if (i + 1 >= args.len) return error.MissingInput;
            input_path = args[i + 1];
            i += 1;
        } else if (std.mem.eql(u8, arg, "--output")) {
            if (i + 1 >= args.len) return error.MissingOutput;
            output_path = args[i + 1];
            i += 1;
        }
    }

    if (input_path == null or output_path == null) {
        std.log.err("Usage: tzdb_generator --input <path> --output <path>", .{});
        return error.MissingArguments;
    }

    const cwd = std.fs.cwd();
    var input_file = try cwd.openFile(input_path.?, .{});
    defer input_file.close();
    const file_info = try input_file.stat();
    const size = @as(usize, @intCast(file_info.size));
    var input_buffer = try allocator.alloc(u8, size);
    defer allocator.free(input_buffer);
    const read_len = try input_file.readAll(input_buffer);
    const input_data = input_buffer[0..read_len];

    const parsed = try std.json.parseFromSlice(RawRoot, allocator, input_data, .{});
    defer parsed.deinit();
    const root = parsed.value;

    var output_file = try cwd.createFile(output_path.?, .{ .truncate = true });
    defer output_file.close();

    try output_file.writeAll("// Code generated by `zig build tzdb`. DO NOT EDIT.\n");
    try output_file.writeAll("const std = @import(\"std\");\n\n");
    try writeFormatted(&output_file, allocator, "pub const VERSION = \"{s}\";\n\n", .{root.version});

    try output_file.writeAll("pub const TZRule = struct {\n");
    try output_file.writeAll("    offset_seconds: i32,\n");
    try output_file.writeAll("    dst_offset_seconds: i32,\n");
    try output_file.writeAll("    starts_at: i64,\n");
    try output_file.writeAll("    ends_at: i64,\n");
    try output_file.writeAll("    name: []const u8,\n");
    try output_file.writeAll("};\n\n");

    try output_file.writeAll("pub const TimeZoneData = struct {\n");
    try output_file.writeAll("    name: []const u8,\n");
    try output_file.writeAll("    rules: []const TZRule,\n");
    try output_file.writeAll("};\n\n");

    try output_file.writeAll("pub const TIMEZONE_DB = [_]TimeZoneData{\n");

    for (root.timezones) |tz| {
        try output_file.writeAll("    .{\n");
        try writeFormatted(&output_file, allocator, "        .name = \"{s}\",\n", .{tz.name});
        try output_file.writeAll("        .rules = &[_]TZRule{\n");

        const min_ts: i64 = std.math.minInt(i64);
        const max_ts: i64 = std.math.maxInt(i64);

        for (tz.rules, 0..) |rule, idx| {
            const start_ts: i64 = if (rule.from) |value| value else min_ts;
            const end_ts: i64 = blk: {
                if (idx + 1 < tz.rules.len) {
                    const next_rule = tz.rules[idx + 1];
                    const next_start = if (next_rule.from) |value| value else min_ts;
                    break :blk next_start;
                }
                break :blk max_ts;
            };

            try writeFormatted(
                &output_file,
                allocator,
                "            .{{ .offset_seconds = {d}, .dst_offset_seconds = {d}, .starts_at = {d}, .ends_at = {d}, .name = \"{s}\" }},\n",
                .{ rule.offset, rule.dst, start_ts, end_ts, rule.abbr },
            );
        }

        try output_file.writeAll("        },\n");
        try output_file.writeAll("    },\n");
    }

    try output_file.writeAll("};\n\n");

    try output_file.writeAll("pub fn lookupTimeZone(name: []const u8) ?TimeZoneData {\n");
    try output_file.writeAll("    inline for (TIMEZONE_DB) |tz| {\n");
    try output_file.writeAll("        if (std.mem.eql(u8, tz.name, name)) return tz;\n");
    try output_file.writeAll("    }\n");
    try output_file.writeAll("    return null;\n");
    try output_file.writeAll("}\n\n");

    try output_file.writeAll("pub fn allTimeZones() []const TimeZoneData {\n");
    try output_file.writeAll("    return TIMEZONE_DB;\n");
    try output_file.writeAll("}\n");
}
